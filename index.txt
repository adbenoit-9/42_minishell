*******************************************************
************************ INDEX ************************
*******************************************************

Afficher un prompt en l’attente d’une nouvelle commande:
    - On utilisera surement un read
Chercher et lancer le bon executable: 
    - $PATH stock les chemins qui permet d'accéder aux exécutables
echo:
    - arg -n => pas de retour a la ligne
    - $ => 
        ex : 
        * echo '\n' = \n
        * echo \n = n
        * echo $'\n' = retour a la ligne
        * echo $"\n" = \n
        conclusion : 
cd:
    ** OÙ ? **
        - arg - ? dans la variable env OLDPWD (je sais pas si on doit le gerer)
        - sans arg ? dans la variable env HOME
pwd:
    - marche normalement qu'importe l'argument
    ** OÙ ? **
        - dans la variable env PWD
export:
    - sans arg particulier
    - ne fait rien s'il ne trouve pas '='
    - peut export plusieurs variables
        ex : 'export test=ok hcbsvbdk test1=cool', dans env on aura : test=ok et test1=cool
unset:
    - ne fait rien s'il ne trouve pas la variable
    - peut unset plusieurs variables
        ex : 'unset test hcbsvbdk test1', test et test1 supprimées d'env
    - erreur si il y a un '=' mais ne stop pas la commande
        ex : 'unset test= test1' erreur sur 'test=' et test1 supprimées d'env
env:
    ** OÙ ? **
        - int main(int argc, char *argv[], char *envp[])
exit:
    - juste fermer notre programme de va pas etre correcte car
    plusieurs ouvertures de bash = plusieurs exit.
    - solution ? fork ? j'ai pas encore tout compris de ce truc
point virgule:
    - exécute les commandes a la suite
    - si une a une erreur, va quand meme executer les autres
guillemets:
    - def
        * simple : pour conserver la valeur littérale de chaque caractère entre guillemets
        * double : comme simple mais avec exeptions => $ accolades (guillemets simples inversés, ``) et \
                    \ : garde sa signification avant \, ", $
    - "' '" = ' ' / '" "' = " "
    - ""double"" = double / ''double'' = double
    - 'simple' = simple /  - "simple" = simple
backslash: ex:
            - \'a = 'a
            - \a = a
            - \\a = \a
redirections:
    - def
        * > : redirige dans un fichier et l'écrase s'il existe déjà
        * >> : ediriger à la fin d'un fichier
        * < : envoie le contenu d'un fichier à une commande
dollar:
    - $VARIABLE_ENVIRONNEMENT : la récupérer dans env
$?:
    - l'état de sortie de la dernière commande exécutée
pipe:
    - idée : utiliser les redirections
CTRL-C: nouvelle ligne bash
CTRL-D: exit
CTRL-\: bah euh ca fait rien lol
